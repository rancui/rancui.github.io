{"meta":{"title":null,"subtitle":null,"description":"技术分享blog","author":"fe team","url":"https://rancui.github.io"},"pages":[],"posts":[{"title":"H5动画之逐帧动画","slug":"H5动画之逐帧动画","date":"2018-05-22T02:31:50.000Z","updated":"2018-05-22T04:18:15.810Z","comments":true,"path":"2018/05/22/H5动画之逐帧动画/","link":"","permalink":"https://rancui.github.io/2018/05/22/H5动画之逐帧动画/","excerpt":"","text":"什么是逐帧动画 要了解 CSS3 逐帧动画，首先要明确什么是逐帧动画。 看一下维基百科中的定义： 定格动画，又名逐帧动画，是一种动画技术，其原理即将每帧不同的图像连续播放，从而产生动画效果。 简而言之，实现逐帧动画需要两个条件：（1）相关联的不同图像，即动画帧；（2）连续播放。 我们儿时的记忆，手翻书，他所实现的就是逐帧动画： （图片来源：知乎） 前端逐帧动画实现方案 在细聊 css3 逐帧动画之前，我们先大致了解下前端实现逐帧动画有哪些方案。 其实不外乎三种技术（视频可以实现所有类型的动画，暂不纳入）：gif、JavaScript、CSS3 Animation。 前文提到，实现逐帧动画需要两个条件：（1）动画帧；（2）连续播放。 下面我们仔细自己分析下这三种技术是怎么实现上述条件的： （1）gif在触屏页中，gif 常被用来做加载动画。如《陌陌不孤独饭局》的加载动画： gif 可以有多个动画帧，连续播放是其自身属性，是否循环也是由其本身决定的。它往往用来实现小细节动画，成本较低、使用方便。 但其缺点也是很明显的： 画质上，gif 支持颜色少(最大256色)、Alpha 透明度支持差，图像锯齿毛边比较严重； 交互上，不能直接控制播放、暂停、播放次数，灵活性差； 性能上，gif 会引起页面周期性的 paint ，性能较差。 （2）JavaScriptJS 与 CSS3，一般是将动画帧放到背景图中。 不同的是， JS 是使用脚本来控制动画的连续播放的： 可以直接改变元素的 background-image 也可以将动画帧合并成雪碧图，通过改变 background-position 来实现 还是《陌陌不孤独饭局》的例子： 其中有一个伸手取饭盒的动画，一共有19帧，且在第11帧处有一个交互，将雪碧图放入背景中，通过不同的样式实现不同的 background-position ，使用 JS 改变样式名： 1234567.sprite-rice-1,.sprite-rice-2,….sprite-rice-19&#123; background-image:url(http://7xnvb2.com2.z0.glb.qiniucdn.com/img/rice.jpg); background-repeat:no-repeat&#125; 1234.sprite-rice-1&#123;background-position:-1800px 0&#125;.sprite-rice-2&#123;background-position:-900px -489px&#125;….sprite-rice-19&#123;background-position:-1200px 0&#125; 使用 JS 的优点是兼容性佳，交互灵活。 （3）CSS3 AnimationCSS3 实际上是使用 animation-timing-function 的阶梯函数 steps(number_of_steps, direction) 来实现逐帧动画的连续播放的。 在移动端，CSS3 Animation 兼容性良好，相对于 JS，CSS3 逐帧动画使用简单，且效率更高，因为许多优化都在浏览器底层完成。 因此在触屏页面中 CSS3 逐帧动画使用广泛，下文将对其进行详细介绍。 CSS3 逐帧动画的实现 （1）将动画帧合并为雪碧图在触屏页面中，动画往往承担页面样式实现的角色（即不需要替换），因此我们会将图片放到元素的背景中（background-image）。 逐帧动画有不同的动画帧，我们可以通过更改 background-image 的值实现帧的切换，但多张图片会带来多个 HTTP 请求，且不利于文件的管理。 比较合适的做法，是将所有的动画帧合并成一张雪碧图（sprite），通过改变 background-position 的值来实现动画帧切换。因此，逐帧动画也被称为“精灵动画（sprite animation）”。 以京东到家的触屏页面《年货送到家》为例： 这个动画一个有三帧，将3个动画帧合并，并放到 .p8 .page_key 的背景中： 123456.p8 .page_key &#123; position: absolute; width: 572px; height: 586px; background-image: url(&quot;../img/p8.png&quot;);&#125; （2）使用 steps 实现动画播放steps 指定了一个阶梯函数，包含两个参数： 第一个参数指定了函数中的间隔数量（必须是正整数）； 第二个参数可选，指定在每个间隔的起点或是终点发生阶跃变化，接受 start 和 end 两个值，默认为 end。 （参考自W3C） 通过W3C中的这张图片来理解 steps 的工作机制： 回到上述的例子，我们在 keyframes 中定义好每个动画帧： 123456@-webkit-keyframes p8&#123; 0%&#123;background-position: 0 0;&#125; 33.33%&#123;background-position: 0 -586px;&#125; 66.66%&#123;background-position: 0 -1172px;&#125; 100%&#123;background-position: 0 -1758px;&#125;&#125; 然后，给他加上 animation： 123.p8 .page_key&#123; -webkit-animation: p8 steps(1,end) 1.5s infinite;&#125; 为什么第一个参数是1？ 前文中提到，steps 是 animation-timing-function 的一个属性值，在 W3C 中有如下说明： For a keyframed animation, the ‘animation-timing-function’ applies between keyframes, not over the entire animation. 也就是说，animation-timing-function 应该于两个 keyframes 之间，而非整个动画。在上面的 keyframes 中，我们已经把每个帧都写出来了，所以两个 keyframes 之间的间隔是1。 更加简便的写法？ 既然说 steps 第一个参数是指函数的间隔数量，那么我们就可以把 keyframes 的计算直接交给 steps 来完成。 123456.p8 .page_key&#123; -webkit-animation: p8 steps(3,end) 1.5s infinite;&#125;@-webkit-keyframes p8 &#123; 100% &#123;background-position: 0 -1758px;&#125;&#125; 以上两种写法效果是等同的。 CSS3 逐帧动画使用技巧 （1）step-start 与 step-end除了 steps 函数，animation-timing-function 还有两个与逐帧动画相关的属性值 step-start 与 step-end： step-start 等同于 steps(1,start)：在变化过程中，都是以下一帧的显示效果来填充间隔动画； step-end 等同于 steps(1,end)：都是以上一帧的显示效果来填充间隔动画。 （2）动画帧的计算：123456$spriteWidth: 140px; // 精灵宽度 @keyframes ani &#123; 100% &#123; background-position: -($spriteWidth * 12) 0; // 12帧 &#125;&#125; （3）适配方案：rem+scale我们知道，rem 的计算会存在误差，因此使用雪碧图时我们并不推荐用 rem。如果是逐帧动画的话，由于计算的误差，会出现抖动的情况。 那么在触屏页中，如何实现页面的适配？ 这里小编提供一个思路： 非逐帧动画部分，使用 rem 做单位； 逐帧动画部分，使用 px 做单位，再结合 js 对动画部分使用 scale 进行缩放。","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://rancui.github.io/tags/动画/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"H5动画之补间动画","slug":"H5动画之补间动画","date":"2018-05-21T09:32:18.000Z","updated":"2018-05-22T04:19:12.743Z","comments":true,"path":"2018/05/21/H5动画之补间动画/","link":"","permalink":"https://rancui.github.io/2018/05/21/H5动画之补间动画/","excerpt":"","text":"什么是动画 动画本质上是图像按照事先设定好的顺序在一定的时间内的图像序列变化运动。 什么是补间动画 看一下百度百科的定义： 补间动画指的是做flash动画时，在两个关键帧中间需要做“补间动画”，才能实现图画的运动；插入补间动画后两个关键帧之间的插补帧是由计算机自动运算而得到的。 在触屏页面中，常见的实现补间动画以下几种形式： 第一，CSS3 Animation。 通过animation(除steps()以外的时间函数)属性在每个关键帧之间插入补间动画。animation属性结合自定义动画@keyframes的使用,改变元素的相应属性制作动画效果。 animation主要常用的属性： animation-name: @keyframes 动画的名称； animation-duration: 动画完成的时间； animation-timing-function: 动画的速度曲线（linear,ease,ease-in,cubic-bezier(n,n,n,n)); animation-delay: 动画何时开始； animation-iteration-count: 动画被播放的次数,默认是1(n,infinite) animation-direction: 规定是否应该轮流反向播放动画。 animation-play-state: 动画处于播放或则暂停状态(paused,running); #circle{ width:150px; height:150px; margin:50px 100px; border-radius:100px; background:yellow; animation:run 1s alternate infinite; } @-webkit-keyframes run{ 0%{ transform:scale(0.5) rotateY(0deg) } 100%{ transform:scale(1) rotateY(360deg) } } @-webkit-keyframes rotate{ 0%{ transform:rotate(0deg) } 100%{ transform:rotate(360deg) } } 第二，CSS3 Transition transition-property: 指定CSS属性的name，transition效果 transition-duration: transition效果需要指定多少秒或毫秒才能完成 transition-timing-function : 指定transition效果的转速曲线 transition-delay: 定义transition效果开始的时候 请把鼠标指针放到黄色的 div 元素上，来查看过渡效果。 #rect{ width:150px; height:150px; margin:0 100px; background:yellow; transition:width 2s, height 2s; -moz-transition:width 2s, height 2s, -moz-transform 2s; /* Firefox 4 */ -webkit-transition:width 2s, height 2s, -webkit-transform 2s; /* Safari and Chrome */ -o-transition:width 2s, height 2s, -o-transform 2s; /* Opera */ } #rect:hover { width:200px; height:200px; transform:rotate(180deg); -moz-transform:rotate(180deg); /* Firefox 4 */ -webkit-transform:rotate(180deg); /* Safari and Chrome */ -o-transform:rotate(180deg); /* Opera */ } 区别于animation，transition只能设定初始和结束时刻的两个关键帧状态。第三，利用JavaScript实现动画 例如JavaScript动画库或框架，著名的有TweenJS，Velocity.js。 第四，SVG 动画。 基于移动端对SVG技术的友好的支持性，利用SVG技术实现动画也是一种可行的方案。 对于利用Transition实现的动画而言，是有一定局限的。 transition的优点在于简单易用，但是它有几个很大的局限。（1）transition需要事件触发，所以没法在网页加载时自动发生。（2）transition是一次性的，不能重复发生，除非一再触发。（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 由于这样的局限，在触屏页面中很少见到Transition动画的身影，但是并不意味着没有，譬如翻页动画的实现可以利用Javascript脚本配合transition与transform属性来实现。 案例截图来源于《京东：2015JDC燃爆事件》 对应的 Chrome Dev Tool 代码调试截图 所以，利用CSS3实现动画的重头戏都在于Animation的运用。然而想写好CSS3 Animation动画需要花费一些力气，这是看似简单实则需要把握好细节的活儿。 动画过程要预先规划好，这可不是是敲敲脑壳就能码出来的事儿。可以是一张把与设计师沟通的结果加之分析输出一张动画属性分解表。 动画属性分解表示例 又或者是根据沟通分析规划出来的动画时间轴。 动画时间轴 动画要自然不生硬，十二法则你值得拥有不管是在影视动画界，还是前端动画界里遵循的都是同一套配方，追求同样的味道——「迪士尼九老」总结的十二黄金动画法则（以下简称“十二法则”），一直沿用至今、备受推崇不是没有道理的。 在一些优秀的触屏页面案例里，可以追寻到它的踪迹。 案例截图来源于《腾讯：微众银行》中的摩托车demo 作者对轮子和摩托车的处理就体现出“挤压和拉伸”的法则，带出颠簸的现实感。 非常推荐大家去认真研究这个案例的，因为作者陈在真就此说明过他的这部作品就完全是遵循迪士尼动画十二原则所码出来的。 但是很可惜，案例已经下线了。 不过，你还可以欣赏到另一位对迪士尼十二法则同样有心得的大神EC的作品《拍拍小店全新上线》。 案例截图来源于《拍拍小店全新上线》 盒子的打开过程就带有一个往上展开预备动作(ANTICIPATION)，并且展开撒开的碎彩纸带有慢出(SLOW OUT)的效果，拍拍小店的logo弹出符合弧形(ARCS)的运动轨迹。 除此之外弧形运动轨迹最为明显的地方就是页面切换的过程。 整个案例处处都非常生动自然、利落感满满，令人赞叹。 另外，在把控十二法则时为了动画更加自然，时间函数(animation-timing-function)的设计绝对是举足轻重的一环，因为动画可以说是一种关于时间函数的运动演变过程。 码好了动画，做好了页面，以为就此结束了吗？不要太天真，移动端对性能的要求也是一道需要迈过的坎儿。Google在有关动画性能渲染优化的文章《动画 | Web Fundamentals - Google Developers》（对不起，这里有道墙）中提出建议: 避免为开销大的属性设置动画，要让每次在设置动画时必须注意保持 60fps。 那么，哪些是开销大的属性呢？（下面是科普环节，清楚的童鞋可以跳过）。 页面渲染的一般过程为JS &gt; CSS &gt; 计算样式 &gt; 布局 &gt; 绘制 &gt; 渲染层合并。 其中，Layout(重排)和Paint(重绘)是整个环节中最为耗时的两环，所以我们尽量避免着这两个环节。从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做渲染层的合并即可。 那怎么知道哪些CSS属性的改变是会影响这两个环节的呢？诺，下面就是各CSS属性与其影响的环节。 截图来源于CSS Triggers，更为详细地翻墙去拿吧 在实际的应用里，最为简单的一个注意点就是，触发动画的开始不要用diaplay:none属性值，因为它会引起Layout、Paint环节，通过切换类名就已经是一种很好的办法。 123456789101112// 根据类名触发动画.active &#123; &amp;.flow_away &#123; .mobile, .ground, .platform, .words &#123; -webkit-animation: flowAwayUp ease .5s forwards; animation: flowAwayUp ease .5s forwards; &#125; &#125;&#125; 还有就是，translate属性值来替换top/left/right/bottom的切换，scale属性值替换width/height，opacity属性替换display/visibility等等。 总结来源于@登平登平的《H5动画60fps之路》 最后总结下要点就是 事先做好规划 码的时候注意十二法则 谨记避免导致layout/paint的属性","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://rancui.github.io/tags/动画/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"微信小程序初探之24点游戏开发","slug":"wxgame-24点游戏开发","date":"2016-10-12T02:20:00.000Z","updated":"2016-10-13T04:59:28.788Z","comments":true,"path":"2016/10/12/wxgame-24点游戏开发/","link":"","permalink":"https://rancui.github.io/2016/10/12/wxgame-24点游戏开发/","excerpt":"","text":"小程序目前还在内测，不过微信已经发布了正式版开发者工具以及API，无需内测邀请也可以先试试了。这几天边学习边试着写了一个简单小游戏，做一个小分享，抛砖引玉，如有错误欢迎指正。 第一步：开发工具官方下载地址 选自己系统对应的版本下载，安装，微信扫码登录即可。 第二步：新建项目初学者可以从官网下载一些demo进行观摩学习，或者新建项目。本例从新建项目开始： 勾选在当前目录创建 quick start 项目会自动生成基础框架。创建成功后进入主窗口，全中文界面，非常清晰友好，无需多言。 我们先打开“编辑”界面，能看到除了page和utils两文件夹以外的app.js/app.wxss/app.json 三个文件，他们定义了小程序的框架。其中，app.wxss 定义整个小程序的通用样式，我们可以理解成之前开发项目时常用的base.css 之类；之后的每个框架界面都会引用到这里的样式设置，并且如果框架界面里有同名的样式，将会覆盖它。 app.js里，App() 函数用来注册一个小程序。接受一个 object 参数，指定小程序的生命周期函数等；下面有一个 globalData 可以设置全局变量，我们设置一个最大数值： globalData:{maxNum:10} 在里面的框架页面如果需要用到此全局变量，代码如下： var appInstance = getApp(); var max = appInstance.globalData.maxNum; app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。我们先打开app.json文件，改动window下的设置，将标题栏文字改成项目名称，并对颜色做些设置。 开发阶段还可将debug属性设置为true，有助于调试。改完后的app.json整体如下： { &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;backgroundTextStyle&quot;: &quot;dark&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#06254c&quot;, &quot;navigationBarTitleText&quot;: &quot;24点游戏&quot;, &quot;windowBackground&quot;: &quot;#06254c&quot;, &quot;navigationBarTextStyle&quot;: &quot;white&quot; }, &quot;debug&quot;:true } 之后我们打开pages/index文件夹，开始第一个页面的开发。 第三步：第一个界面在我设想里，第一个界面将会有一个进入游戏的欢迎词、一个游戏玩法说明以及一个开始游戏的按钮。 因此在index.wxml里，我写上 &lt;view class=&quot;container&quot;&gt; &lt;view bindtap=&quot;bindViewTap&quot; class=&quot;userinfo&quot;&gt; &lt;text class=&quot;welcome&quot;&gt;欢迎{{userInfo.nickName}}进入24点小游戏&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;specification-box&quot;&gt; &lt;text&gt;{{specification}}&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;page-bottom&quot;&gt; &lt;button class=&quot;page-btn&quot; bindtap=&quot;gotoCount&quot;&gt;现在就开始玩吧&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; 说明：小程序里基础组件的API地址 然后在index.wxss里配置样式，基本上是css的简化版，前端都懂得。需要留意的是小程序给了两种单位：rpx和rem，都实现了屏幕适配，我们不需要额外纠结，看看说明文档 吧。 按钮上通过bindtap关联的gotoCount、通过api接口读取到的用户数据以及玩法说明等需要在index.js里定义： var app = getApp() Page({ data: { specification: &apos;玩法说明：\\n 进入游戏后，点击数字及运算符得出结果；前几步计算出的结果同样可以点击进行下一步运算。将给出的牌数用尽并得出24即为胜出。&apos;, userInfo: {} }, //开始游戏 跳转到下一页 gotoCount() { wx.navigateTo({ url: &apos;../count/count&apos;}); }, onLoad: function () { var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo){ //更新数据 that.setData({ userInfo:userInfo }) }) } }) 先通过getApp()取到app实例，在page里通过data绑定动态数据，其中的值在页面里通过花括号直接引用，如specification，也可以在各种交互中通过setData进行增改，如本例中,初始设定为空对象的userInfo 即在后面被设置成默认用户昵称。 navigateTo假如需要携带参数跳转，在url后加问好+参数名=参数值传递；在接收页 通过options接收处理， 具体说明 第四步：编写游戏界面新建框架界面要新建框架界面首先要先新建一个文件夹、在文件夹里新建四种类型的同名文件，并在app.json的page里将文件注册进去才可正常编译。如图： app.json 里，pages数组增加一行： &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/count/count&quot; ], 现在去点击调试，将出现界面： 点击按钮 进入一个上面有菜单栏、下面空白的界面，这就是有待我们开发的count了。 先看一下界面 （红色为截图标注说明） 结果反馈： count.jscount.js 里的代码结构： 点调试，看看默认的动态数据情况： 展开： 这些就是在count.js的data里设定的（有些直接指定初始值、有些通过creatUnit生成设置）。对以上数据有概念之后去看界面： count.wxm在count.wxml里别写几个区域，我的代码结构如下： 分别来看： page-button这个view里有如下代码：&lt;button wx:for=&quot;{{numbers}}&quot; bindtap=&quot;usetoCount&quot; disabled=&quot;{{disabled[index]}}&quot; class=&quot;{{disabled[index]?'card disabled':'card active'}}&quot; data-index = &quot;{{index}}&quot; data-num=&quot;{{item}}&quot;&gt; {{item}} &lt;/button&gt; 用了button组件，通过 wx:for 定义了循环，数据来源是numbers，它是count.js里的data里的numbers数组，结果是numbers数组有几个数据这边就将出现几个按钮（本游戏4个）； for列表循环里默认index表示索引、item表示对应内容，也就是说假设一个[‘+’,’-‘]数组用于循环，则index和item将分别循环出0、1 以及 “+”、”-“。 wx:for相关API地址 按钮都绑定tap事件关联usetoCount方法;默认可点击，点击后将数字列到下面算式列表中，同时自身变成不可用状态； 按钮的样式通过disabled动态值判断，可点状态是card active否则是card disabled； 通过data-传送2个值，一个是index传递数字索引（用于判定第几个数字已经用了后面不能再用这种意思） 一个是 num 传递本按钮的值，用于运算，这些都将在usetoCount里用到。 放运算符的view里只有一句话： &lt;button class=&quot;operator&quot; bindtap=&quot;useOperator&quot; wx:for=&quot;{{['+','-','*','/']}}&quot; data-operator=&quot;{{item}}&quot;&gt;{{item}}&lt;/button&gt; 同上，用for循环加减乘除四个字符列出四个运算符按钮。 放运算列表的view里也是一个循环，取数据countLine，里面放点击后的数字以及运算符、等号按钮以及当前列计算结果 &lt;view class=&quot;count-list&quot; wx:for=&quot;{{countLine}}&quot;&gt; &lt;text class=&quot;number&quot;&gt;{{item.firstNum}}&lt;/text&gt; &lt;text class=&quot;number&quot;&gt;{{item.operator}}&lt;/text&gt; &lt;text class=&quot;number&quot;&gt;{{item.nextNum}}&lt;/text&gt; &lt;button wx:if=&quot;{{item.firstNum && item.operator && item.nextNum}}&quot; disabled=&quot;{{result.length>index}}&quot; class=&quot;{{result.length>index?'operator disabled':'operator'}}&quot; bindtap=&quot;toCount&quot;&gt; = &lt;/button&gt; &lt;button wx:if=&quot;{{result[index]}}&quot; bindtap=&quot;usetoCount&quot; data-num = &quot;{{result[index]}}&quot; class=&quot;{{disabled[index+4]?'operator disabled':'operator'}}&quot; disabled=&quot;{{disabled[index+4]}}&quot; data-index = &quot;{{index+4}}&quot;&gt; {{result[index]}} &lt;/button&gt; &lt;/view&gt; 最后 反馈用了另一个组件modal &lt;modal title=&quot;{{isSuccessed?'祝贺你，成功了！':'失败了'}}&quot; confirm-text=&quot;下一题&quot; cancel-text=&quot;重新算一次&quot; hidden=&quot;{{modalHidden}}&quot; bindconfirm=&quot;getNextUnit&quot; bindcancel=&quot;reCount&quot; /&gt; 标题通过isSuccessed判定，两个按钮分别用于下一题以及重算。其中,modalHidden 初始设定为真，也就是开始默认隐藏，等结果出来后才显示反馈结果。 完整代码实现有点啰嗦，持续优化中，附上git地址：https://github.com/gbyuxia/wx-game-24 如需转载，请注明出处~~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"JavaScript常用API那些事儿","slug":"yuanchuang-常用API那些事儿","date":"2016-10-09T16:00:00.000Z","updated":"2016-10-11T10:33:01.404Z","comments":true,"path":"2016/10/10/yuanchuang-常用API那些事儿/","link":"","permalink":"https://rancui.github.io/2016/10/10/yuanchuang-常用API那些事儿/","excerpt":"","text":"短暂的十一假期，感觉还没开始就结束了。。。。 但是，说过的话话是要算数滴~~ 今天我们就来聊聊JavaScript常用的API那些事儿吧~~~ 想到js，整个人的脑袋就感到······ 但从事前端开发，js是必须要会的。不仅仅是前端人员，后端人员也会用到。 那么，在工作中常用到javascript的API有哪些呢？ 一. 元素查找 123456789101112131415161718 //nodedocument.getElementById();// 这个就不用注释是啥意思了吧？！document.querySelector();//该方法返回文档中匹配指定 CSS 选择器的第一个元素。document.body;// 返回文档的body元素document.head;// 返回文档的head元素document.title;// 返回当前文档的标题document.documentElement;//根元素，指htmldocument.doctype;// 返回 html文档的文档类型对象document.readyState;// 返回文档状态 (载入中……)//nodeListdocument.querySelectorAll();document.getElementsByClassName();document.getElementsByTagName(); document.scripts; // 返回页面中所有脚本的集合document.forms; // 返回对文档中所有 Form 对象引用document.images;// 返回对文档中所有 Image 对象引用。 二. class操作 我们平时常用的jquery里面有addClass(), removeClass(),toggleClass(),hasClass()这些api。 但HTML5时代，classList API出现了，classList 属性返回元素的类名，作为 DOMTokenList 对象。 classList实际上已经出现好多年了，因此，FireFox浏览器，Chrome浏览器都支持。IE家族中，从IE10浏览器开始才开始认可classList。 移动端，Android 3.0+以上才开始支持，时至今日，移动端可以说已经几乎全部支持该api。 123456789101112131415 //增加类名, 以下皆以\"classname\"类名为例。 document.getElementById(\"myDIV\").classList.add(\"classname\");//移动类名document.getElementById(\"myDIV\").classList.remove(\"classname\");//返回布尔值，判断指定的类名是否存在document.getElementById(\"myDIV\").classList.contains(\"classname\");//返回类名在元素中的索引值。index是索引值，索引值从 0 开始;document.getElementById(\"myDIV\").classList.item(index);//类名切换document.getElementById(\"myDIV\").classList.toggle(\"classname\"); 三. 属性操作 123456//元素的图片路径element.getAttribute(\"src\");//设置元素的图片路径element.setAttribute(\"src\",\"图片的路径\"); 四. 节点操作 123456789101112131415161718//创建元素var element = document.createElement(name);// true，克隆节点及其属性和后代； false，克隆节点和后代；element.cloneNode(true);//追加子元素element.appendChild(child);//父元素element.parentNode; //删除子元素element.parentNode.removeChild(child);//在指定的节点前插入子节点parentNode.insertBefore(element,parent.childNodes[0]); 五. css操作 获取元素的样式一般有currentStyle，getComputedStyle,style这三种来就获取css的值，jquery中的css()底层其实也是用到了getComputedStyle。 以下是获取css样式,以元素element为例。 1234567891011element.currentStyle[attrName]；//注意，此处用的是元素elementwindow.getComputedStyle(element)[attrName];//注意，此处用的是windowwindow.getComputedStyle(element,\":before\");//注意，此处用的是window//在移动端我们用style设置css样式的时候一般采用cssText比较好,可以批量操作css样式。//cssText只需一次reflow，提高了页面渲染性能, 例如：element.style.cssText=\"width:100px;height:100px; -webkit-transform:translate3d(0,100%,0)\"; 六. 位置大小在我们实际的工作中，经常会用位置方面的的知识点来获取或者设置一些元素。以下以元素element为例： 12345678910111213141516171819202122232425262728293031323334353637//对象可见内容的宽度(高度同理)不包括滚动条，不包括边框element.clientWidth;//当前对象的宽度(width+padding+border)element.offsetWidth; //获取对象的滚动宽度element.scrollWidth;//获取对象的滚动宽度element.scrollWidth;//获取对象的滚动宽度element.scrollWidth;//获取对象的滚动宽度element.scrollWidth;//相对整个页面的坐标element.pageY //相对可视区域的坐标element.clientY//鼠标在屏幕中的位置，指的是鼠标到电脑屏幕左侧的距离//与clientX的区别是clientX是到浏览器的距离。例如：当网页缩小，拖动到屏幕中间时，screnX 大于 clientXelement.screenX //设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离，也就是元素被滚动条向左拉动的距离。element.scrollLeft；//设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离，也就是元素滚动条被向下拉动的距离。element.scrollTop； 除以上外，还可以用getBoundingClientRect获取元素位置。 getBoundingClientRect用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。该函数返回一个Object对象，该对象有6个属性：top,lef,right,bottom,width,height；这里的top、left和css中的理解很相似，width、height是元素自身的宽高，但是right，bottom和css中的理解有点不一样。right是指元素右边界距窗口最左边的距离，bottom是指元素下边界距窗口最上面的距离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 getBoundingClientRect() 这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。 var box=document.getElementById('box'); console.log(box.getBoundingClientRect().top); console.log(box.getBoundingClientRect().right); console.log(box.getBoundingClientRect().bottom); console.log(box.getBoundingClientRect().left); 注意：IE、Firefox3+、Opera9.5、Chrome、Safari支持，在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两个像素，我们需要做个兼容。 document.documentElement.clientTop; // 非IE为0，IE为2document.documentElement.clientLeft; // 非IE为0，IE为2functiongGetRectObj (element) &#123; var rect = element.getBoundingClientRect(); var top = document.documentElement.clientTop; var left= document.documentElement.clientLeft; return&#123; top : rect.top - top, bottom : rect.bottom - top, left : rect.left - left, right : rect.right - left &#125;&#125; 七. 移动端事件 移动端没有鼠标事件，只有触摸事件，分别是ontouhstart，ontouchmove，ontouchend。 1.在非IE的标准浏览器中，addEventListener()绑定事件的对象方法。addEventListener()含有三个参数，一个是事件名称，另一个是事件执行的函数，最后一个是事件捕获。 obj.addEventListener(“touchmove”,function(){},true/false); 这里的事件名称跟直接写的事件名称不一样，在这里前面没有on。 2.事件属性无论使用触摸还是手势事件，你都需要将这些事件转换为单独的触摸来使用它们。为此，你需要访问事件对象的一系列的属性。 touches: 当前屏幕上所有触摸点的列表; targetTouches: 当前对象上所有触摸点的列表; changedTouches: 涉及当前事件的触摸点的列表 用一个手指接触屏幕，触发事件，此时这三个属性有相同的值。 用第二个手指接触屏幕，此时，touches有两个元素，每个手指触摸点为一个值。当两个手指触摸相同元素时，targetTouches和touches的值相同，否则targetTouches 只有一个值。changedTouches此时只有一个值，为第二个手指的触摸点。用两个手指同时接触屏幕，此时changedTouches有两个值，每一个手指的触摸点都有一个值手指滑动时，三个值都会发生变化一个手指离开屏幕，touches和targetTouches中对应的元素会同时移除，而changedTouches仍然会存在元素。手指都离开屏幕之后，touches和targetTouches中将不会再有值，changedTouches还会有一个值，此值为最后一个离开屏幕的手指的接触点。 3.在IE浏览器中，attachEvent()绑定事件的对象方法。obj.attachEvent(“onclick”,function(){}); 注意此方法中的事件名称要加上on，没有事件捕获。 八. 创建文档碎片 如果当我们要向document中添加大量数据时(比如1w条)，因为每添加一个节点都会调用父节点的appendChild()方法，这个过程就可能会十分缓慢。因此我们可以引入createDocumentFragment()方法，它的作用是创建一个文档碎片，把要插入的新节点先附加在它上面，然后再一次性添加到document中，使用DocumentFragment进行缓存操作，引发一次回流和重绘，提高性能。 12345678910111213141516171819202122232425//先创建文档碎片var Fragmeng = document.createDocumentFragment(); for(var i=0;i&lt;10000;i++)&#123; var aSpan = document.createElement(\"span\"); var aText = document.createTextNode(i); aSpan.appendChild(aText); //先附加在文档碎片中 Fragmeng.appendChild(aSpan); &#125; //最后一次性添加到document中document.body.appendChild(Fragmeng); 以上就是一些分享和总结，如需转载，请注明出处~~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"https://rancui.github.io/tags/项目总结/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"html a 标签实现打电话，发短信功能","slug":"yuanchuang-html a 标签实现打电话，发短信功能","date":"2016-10-09T02:20:00.000Z","updated":"2016-10-11T10:33:17.277Z","comments":true,"path":"2016/10/09/yuanchuang-html a 标签实现打电话，发短信功能/","link":"","permalink":"https://rancui.github.io/2016/10/09/yuanchuang-html a 标签实现打电话，发短信功能/","excerpt":"","text":"前些时间做移动端项目时，偶然发现a标签的带参数发送短信功能在安卓和ios下的写法是有区别的，稍不注意，可能会造成不必要的bug，趁空闲时间总结下笔记，大家一起互相学习。 下面就给大家详细讲一下如何实现和解决实际工作中可能遇到的问题: 关于打电话、发短信功能的实现12&lt;a href=&quot;tel:10086&quot;&gt;打电话给：10086&lt;/a&gt;&lt;a href=&quot;sms:10086&quot;&gt;发短信给：10086&lt;/a&gt; 实际在项目中应用时，发短信功能有时候需要带参数文案发送，安卓和ios的写法如下: 安卓系统上面的写法是： 1&lt;a href=&quot;sms:10086?body=你好Android&quot;&gt;给 10086 发短信&lt;/a&gt; ios系统上面的写法是： 1&lt;a href=&quot;sms:10086&amp;body=你好iphone&quot;&gt;给 10086 发短信&lt;/a&gt; 做项目时应用demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1,minimum-scale=1 maximum-scale=1, user-scalable=0\"&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; &lt;meta name=\"format-detection\" content=\"telephone=no\"&gt; &lt;title&gt;示例&lt;/title&gt; &lt;style&gt; a&#123;display: block;margin:10px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"tel\"&gt; &lt;a href=\"tel:10086\"&gt;给10086打电话&lt;/a&gt; &lt;a href=\"sms:10086\"&gt;给10086发短信&lt;/a&gt; &lt;a href=\"sms:10086?body=你好Android\" id=\"js-sms\"&gt;给 10086 发短信&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; //默认是给安卓发短信 判断为iphone后 改变写法 if(browser.versions.iPhone==true)&#123; document.getElementById('js-sms').setAttribute('href','sms:10086&amp;body=你好iphone') &#125; // document.writeln(\"语言版本: \"+browser.language); // document.writeln(\" 是否为移动终端: \"+browser.versions.mobile); // document.writeln(\" ios终端: \"+browser.versions.ios); // document.writeln(\" android终端: \"+browser.versions.android); // document.writeln(\" 是否为iPhone: \"+browser.versions.iPhone); // document.writeln(\" 是否iPad: \"+browser.versions.iPad); // document.writeln(navigator.userAgent); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如需转载，请注明出处~~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"Load","slug":"Load","permalink":"https://rancui.github.io/tags/Load/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"微信小程序入门","slug":"wxa-微信小程序入门","date":"2016-09-29T15:14:33.000Z","updated":"2018-05-22T05:28:36.637Z","comments":true,"path":"2016/09/29/wxa-微信小程序入门/","link":"","permalink":"https://rancui.github.io/2016/09/29/wxa-微信小程序入门/","excerpt":"","text":"9月22日，微信小程序开始小范围内测。几天后微信官方发布了小程序开发文档以及小程序开发者工具。一口气看完了所有的开发文档，一个很直观的感受就是前端可以直接使用前端知识以及借助后端云服务很方便的开发应用了。 下面就讲一下微信小程序相关的基本用法 安装小程序开发者工具从微信官方下载小程序开发者工具并安装，安装好后启动开发者工具，使用微信扫描登录。 新建项目点击“添加项目”，填写AppID(如果没有AppID，选择下方的无AppID即可)和项目名称，选择项目目录，点击添加项目即可。初次使用可以选择下面的创建一个 quick start 项目，这样会在开发目录里生成一个简单的 demo。 小程序开发者工具介绍(1)编辑编辑界面左边为项目的文件列表，右边为编辑窗口。在文件列表中点击文件即可在编辑窗口中对此文件进行编辑。 (2)调试调试界面左边页面预览，其中左边的上面可以选择模拟的机型和网络右边和chrome的调试工具界面非常类似。其中Storage是应用在本地存储的数据，AppDate是当前页面的一些数据信息。 (3)项目此界面为应用上传和预览界面 (4)重启重启当前应用 (5)后台当前应用在后台运行，可以再次切换到前台 (6)缓存可以清除本地存储的数据和文件 (7)关闭关闭当前应用，回到登录(启动)后的界面 小程序代码结构介绍app.jsapp.js主要定义全局的方法和变量以及监听并处理小程序的生命周期 app.jsonapp.json是应用的全局配置文件，配置应用的所有组成页面和应用的界面样式 app.wxssapp.wxss是应用的公共样式文件，和css基本一致 pages目录pages目录下面是应用的所有页面，每个页面都可以单独定义一个目录，目录里面包含4个文件。wxml文件是当前页面的结构文件js文件是当前页面的脚步文件wxss文件是当前页面的样式文件，与公共样式文件app.wxss叠加使用json文件是当前页面的配置文件，与全局配置文件app.json叠加使用 其它小程序结构这块，微信官方定义了一套框架，了解过vue的就会感觉似曾相识。样式这块，微信做了一些自己的扩展和限制，详见WXSS 以上就是微信小程序的基本介绍。更详细的情况请参考微信官方开发文档 如需转载，请注明出处~~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://rancui.github.io/tags/微信小程序/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]},{"title":"移动web开发适配","slug":"yuanchuang-移动web开发适配","date":"2016-09-27T16:00:00.000Z","updated":"2016-10-11T10:33:25.203Z","comments":true,"path":"2016/09/28/yuanchuang-移动web开发适配/","link":"","permalink":"https://rancui.github.io/2016/09/28/yuanchuang-移动web开发适配/","excerpt":"","text":"说到移动web开发，自然而然的会想到H5，那什么是H5呢？ H5是HTML5（HyperText Markup Language 5）超文本标记语言第五次重大版本的简称，标准通用标记语言下的一个应用，也是一种规范和标准。 HTML5本身并非技术，而是标准。现在国内普遍说的 H5 是包括了 CSS3，JavaScript 的说法。 “超文本”就是指页面内可以包含图片、视频、链接、音乐、程序等非文字元素。 2014年10月29日，万维网(W3C)联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成。 HTML5 中的一些有趣的新特性：绘画本地音频视频播放动画地理信息硬件加速离线缓存（即使在没有网络的情况下）本地存储从桌面拖放文件到浏览器上传语义化标签 一.移动开发过的H5前端项目 目前为止，我们团队已做过的基于微信和hybrid开发的前端项目有： 卡卡贷第一版，星星钱袋，学历贷，丽人贷，豆豆钱，豆豆房租，豆豆花，金薪贷，赎楼贷，安家派，手机贷，简历贷，秒分，vcs（PC端贷后催收系统），dashboard以及一些项目的推广活动页。 二.移动开发的适配 1.采用rem单位众所周知，目前苹果手机的屏幕尺寸有4种，但安卓手机的屏幕碎片化却很严重，各种屏幕尺寸，这给我们在做适配的时候也带来了一定的麻烦。为了尽可能的做到全机型的屏幕适配，我们CSS的单位采用的是rem混合px，更主要的是采用rem来做适配，那么什么是rem? 为什么要使用rem？它和px之间又是怎样的一种关系呢？ rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。计算的规则是依赖根元素，这也给px和rem换算带来了很大的便利性。 rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但从一些大厂的同行的反馈以及我们自己的实践来看，rem综合评价是用来做webapp最合适的人选之一。 腾讯手Q的一些推广活动页和淘宝m站也使用了rem：m.taobao.com 做适配的时候，我们可以采用CSS3中的媒体查询@meidia screen and (min-width:xxx) and (max-width:xxx) 单位是px来针对不同范围的手机屏幕尺寸来做适配。但如上所说，安卓手机的屏幕尺寸碎片化严重，这就需要我们写很多的媒体查询也不一定能覆盖所有设备全适配也不利于以后的扩展。因此，我们采用JS实现全适配，单位采用rem。 我们的UI设计师给到的设计稿是iPhone6的尺寸，宽度是750px，那么我们前端在撸码的时候要把px换成rem，它们之间的换算关系如下： 123456789101112131415 (function(doc, win) &#123; var docEl = doc.documentElement, //html根元素 resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth&gt;1500?1500:docEl.clientWidth;//可视区域的宽度，iphone6下是375px if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 750) + 'px';//在750px的设计稿中，1rem=10px，便于换算。 &#125;;if (!doc.addEventListener) return;win.addEventListener(resizeEvt, recalc, false);doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 2.通过zoom来设置：作为一个早期IE的私有属性，其实现在的大部分浏览器也都能支持，zoom具有继承性，所以我们在最外层设置zoom，其子元素也会继承。 1234 //获取做外层的元素var wrapper =document.getElementById(\"wrapper\"); //设置zoomwrapper.style.zoom = Math.min(document.body.clientWidth, document.body.clientHeight) / 320; //320是iphone4s的屏幕大小 所以当用zoom来做适配的时候，就可以完全采用px作单位来编写代码。 那在HTML中又需要设置哪些呢？ 不同于以往的PC端页面开发，移动端页面的头部的meta中，下面这段话是必须配置的：12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; content属性值 : width:网页可视区域的宽度，值可为数字或关键词device-width，可理解为网页的宽度等于手机屏幕的宽度 height:同width intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放 maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别， maximum-scale用户可将页面放大的最大倍数，1.0将禁止用户放大到实际尺寸之上。 user-scalable:是否可对页面进行缩放，no 禁止缩放 三.部分css样式重置 移动端绝大多数浏览器是WebKit内核，所以需加浏览器私有前缀-webkit- 1.去除一些组件的默认样式12345678input,button,textarea,select,optgroup,option &#123; -webkit-appearance: none;&#125; 2.输入框等组件点按会出现一个“暗色”的背景，去掉该背景的方法如下：123a,button,input,optgroup,select,textarea &#123; -webkit-tap-highlight-color:rgba(0,0,0,0); /*去掉a、input和button点击时的蓝色外边框和灰色半透明背景*/&#125; 3.禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加,方法如下:123a, img &#123; -webkit-touch-callout: none; /*禁止长按链接与图片弹出菜单*/&#125; 4.如何移除 input type=”number” 时浏览器自带的上下箭头（以前项目中在小米手机中遇到过这个问题）123456input::-webkit-inner-spin-button &#123;-webkit-appearance: none;&#125;input::-webkit-outer-spin-button &#123;-webkit-appearance: none;&#125; 5.禁止页面文字选择123body&#123;-webkit-user-select: none; &#125; 四. 给body标签加上ontouchstart 还有就是在body标签内，最好也加上ontouchstart , 因为在有的浏览器里面（safari），当你给一个类加上:active状态的时候，如果没有给body加上ontouchstart，那么active的状态就不出来。 五. 1px border问题 什么是1px border问题？ 1在 2014 年的 WWDC，“设计响应的 Web 体验” 一讲中，Ted O’Connor 讲到关于“retina hairlines”（retina 极细的线）：在 retina 屏上仅仅显示 1 物理像素的边框。 现在大家所用的手机大都是高清屏（Retina屏幕），其设备像素比为2或3或4较多，这就造成了在PC端网页中 1px 边框在移动端网页看起来有2px宽度的大小，在视觉体验上不友好，如下图： 这个问题也是一直存在但也是一些前端人员没有注意过的问题。至少在我所面试的大概10多个候选人中，只有两三个人听说过或者处理过这个问题（细节之一啊…） 在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 解决这个问题其实可以有以下6种方法： 1. iOS8 以上支持 0.5px实现原理：常规属性。 123.border &#123; border: 0.5px solid #ff8100;&#125; 优点：原生、简单、常规写法。 缺点：目前只有 iOS8 以上系统才能支持，iOS7及以下、安卓系统都显示为 0px，可以通过脚本判断系统然后区分处理。 2. CSS 渐变模拟实现原理：设置 1px 通过 css 实现的背景图片，50%有颜色，50%透明，以上边框为例(结合媒体查询，最小设备像素比2)： 123456789@media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; .ui-border-t &#123; border:0; background-position: left top; background-image: -webkit-gradient(linear, left bottom, left top, color-stop(0.5, transparent), color-stop(0.5, #cecece), to(#cecece)); background-repeat: repeat-x; -webkit-background-size: 100% 1px; &#125;&#125; 优点：兼容性较好，单边框、多边框可实现，大小、颜色可配置。 缺点：代码量多、同时占用了背景样式 3. 阴影实现原理：利用 css 对阴影处理的方式模拟。 123.border &#123; -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; 优点：兼容性较好，单边框、多边框、圆角可实现，大小、颜色、可配置。 缺点：模拟效果强差人意，颜色不好配置。 4. viewport + rem实现原理：通过设置页面 viewport 与对应 rem 基准值。 12345&lt;!-- devicePixelRatio = 2：--&gt;&lt;meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\"&gt;&lt;!-- devicePixelRatio = 3：--&gt;&lt;meta name=\"viewport\" content=\"initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no\"&gt; 优点：兼容比较好，写法跟常规写法无异。 缺点：老项目改用 rem 单位成本较高。 5. border-image实现原理：通过图片配合边框背景模拟。 1234.border-image&#123; border-image: url() 2 0 stretch; border-width: 0 0 1px;&#125; 优点：无。 缺点：图片边缘模糊，大小、颜色更改不灵活。 6. CSS3 缩放实现原理：利用 :before/:after 重做 border，配合 scale 使得伪元素缩小一半 1234567891011121314151617$bor_style : 1px solid #ff8100;%border-top-1pt &#123; content: ''; height: 0; display: block; border-bottom: $bor_style; position: absolute; left: 0; right: 0; top: 0;&#125;@media only screen and (-webkit-min-device-pixel-ratio:2) &#123; %border-top-1pt &#123; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; &#125;&#125; 优点：实现简单、单边框、多边框、圆角可实现，大小、颜色可配置。 缺点：代码量多，可通过 sass 预处理器处理。 总结：经过比较与实操测试，最好的处理方式是背景渐变和 CSS3 缩放，目前已经在项目中使用。 六.某些安卓机器，在低版本系统里遇到的键盘弹出挡住输入框问题 这个问题，在一些安卓机器的微信里面会出现，这和微信之前内置的X5内核浏览器不无关系。我们团队曾向腾讯负责X5内核浏览器的人反馈过，也得到了回应，给了一个二维码，下载了一个TBS工具集后，点击安装“TBS内核安装” 解决了这个问题。现在微信内置的已是Blink内核。 除此之外，也可以代码解决：1234567891011121314151617181920212223242526272829$(function()&#123; var timer,windowInnerHeight2; var windowInnerHeight = document.documentElement.clientHeight; function eventCheck(e) &#123; if (e) &#123; //blur,focus事件触发的 if (e.type == 'click') &#123;//如果是点击事件启动计时器监控是否点击了键盘上的隐藏键盘按钮，没有点击这个按钮的事件可用，keydown中也获取不到keyCode值 setTimeout(function () &#123;//由于键盘弹出是有动画效果的，要获取完全弹出的窗口高度，使用了计时器 windowInnerHeight2 = document.documentElement.clientHeight;//获取弹出软键盘后的窗口高度 // alert(windowInnerHeight2) $(\"html,body\").scrollTop(windowInnerHeight-windowInnerHeight2-100);//此处数值可根据需要改变 timer = setInterval(function () &#123; eventCheck() &#125;, 50); &#125;, 500); &#125;else&#123; clearInterval(timer) &#125;; &#125;else &#123; //计时器执行的，需要判断窗口可视高度，如果改变说 明键盘隐藏了 if (window.innerHeight &gt; windowInnerHeight)&#123; clearInterval(timer); &#125; &#125; &#125; $(\"xxx\").on(\"click\",eventCheck);// xxx代表你需要做处理的输入框，可自行替换成class或id &#125;) 七.加链接的快速反应在我们做过的项目中推广活动页或多或少都有页面之间的链接，常用的是， 但采用ontouchstart响应速度更快： 1&lt;button class=\"ui-btn\" ontouchstart=\"location.href='./xxx.html'\"&gt;&lt;/button&gt; 感谢您的阅读，以上就是在实际开发中的其中一点积累，希望能够给大家一些帮助。行文匆忙，如有错误不当之处还请指正。 如需转载，请注明出处~~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"https://rancui.github.io/tags/项目总结/"}],"keywords":[{"name":"Web开发","slug":"Web开发","permalink":"https://rancui.github.io/categories/Web开发/"}]}]}